// Generated by CoffeeScript 1.8.0
(function() {
  var SSH2Shell,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  SSH2Shell = (function() {
    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype.response = "";

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype._connections = [];

    SSH2Shell.prototype._processData = function() {
      this._data = this._data.replace(/[^\r\n\x20-\x7e]/g, "");
      this._data = this._data.replace(/(\[[0-9]?[0-9]m)/g, "");
      this._buffer += this._data;
      if (this.command.indexOf("sudo ") !== -1) {
        return this._processPasswordPrompt();
      } else if (this.command.indexOf("ssh ") !== -1) {
        return this._processSSHPrompt();
      } else if (this._buffer.match(/[#$]\s$/)) {
        if (this.sshObj.debug) {
          this.sshObj.msg.send("" + this.sshObj.server.host + ": normal prompt");
        }
        return this._processNextCommand();
      } else {
        return this.sshObj.onCommandProcessing(this.command, this._buffer, this.sshObj, this._stream);
      }
    };

    SSH2Shell.prototype._processPasswordPrompt = function() {
      if (!this.sshObj.pwSent) {
        if (this._buffer.match(/password.*:\s$/i)) {
          if (this.sshObj.debug) {
            this.sshObj.msg.send("" + this.sshObj.server.host + ": Send password [" + this.sshObj.server.password + "]");
          }
          this.sshObj.pwSent = true;
          return this._stream.write("" + this.sshObj.server.password + "\n");
        }
      } else {
        if (this._buffer.match(/password.*:\s$/i)) {
          this.sshObj.msg.send("" + this.sshObj.server.host + ": Error: Sudo password was incorrect for " + this.sshObj.server.userName + ", leaving host.");
          if (this.sshObj.debug) {
            this.sshObj.msg.send("" + this.sshObj.server.host + ": password: [" + this.sshObj.server.password + "]");
          }
          this.sshObj.sessionText += "" + this._buffer;
          this._buffer = "";
          this.sshObj.commands = [];
          return this._stream.write('\x03');
        } else if (this._buffer.match(/[#$]\s$/)) {
          return this._processNextCommand();
        }
      }
    };

    SSH2Shell.prototype._processSSHPrompt = function() {
      var password;
      if (!this.sshObj.sshAuth) {
        if (this._buffer.match(/password.*:\s$/i)) {
          if (this.sshObj.debug) {
            this.sshObj.msg.send("" + this.sshObj.server.host + ": ssh password prompt");
          }
          this.sshObj.sshAuth = true;
          return this._stream.write("" + this.sshObj.server.password + "\n");
        } else if (this._buffer.match(/passphrase.*:\s$/i)) {
          if (this.sshObj.debug) {
            this.sshObj.msg.send("" + this.sshObj.server.host + ": ssh passphrase prompt");
          }
          this.sshObj.sshAuth = "true";
          return this._stream.write("" + this.sshObj.server.passPhrase + "\n");
        } else if (this._buffer.match(/[#$]\s$/)) {
          if (this.sshObj.debug) {
            this.sshObj.msg.send("ssh auth normal prompt");
          }
          this.sshObj.sshAuth = true;
          return this._processNextCommand();
        }
      } else {
        if ((password = this._buffer.match(/password.*:\s$/i)) || this._buffer.match(/passphrase.*:\s$/i)) {
          this.sshObj.sshAuth = false;
          this.sshObj.msg.send("Error: SSH authentication failed for " + this.sshObj.server.userName + "@" + this.sshObj.server.host);
          if (this.sshObj.debug) {
            this.sshObj.msg.send("Using " + (password ? "password: [" + this.sshObj.server.password + "]" : "passphrase: [" + this.sshObj.server.passPhrase + "]"));
          }
          if (this._connections.length > 0) {
            this.sshObj = this._connections.pop();
          }
          return this._stream.write('\x03');
        } else if (this._buffer.match(/[#$]\s$/)) {
          if (this.sshObj.debug) {
            this.sshObj.msg.send("ssh normal prompt");
          }
          return this._processNextCommand();
        }
      }
    };

    SSH2Shell.prototype._processNotifications = function() {
      var msgNote, sessionNote, _results;
      _results = [];
      while (this.command && ((sessionNote = this.command.match(/^`(.*)`$/)) || (msgNote = this.command.match(/^msg:(.*)$/)))) {
        if (sessionNote) {
          this.sshObj.sessionText += "" + this.sshObj.server.host + ": " + sessionNote[1] + "\n";
          if (this.sshObj.verbose) {
            this.sshObj.msg.send(sessionNote[1]);
          }
        } else if (msgNote) {
          this.sshObj.msg.send("" + this.sshObj.server.host + ": " + msgNote[1]);
        }
        _results.push(this.command = this.sshObj.commands.shift());
      }
      return _results;
    };

    SSH2Shell.prototype._processBuffer = function() {
      this.sshObj.sessionText += "" + this._buffer;
      this.response = this._buffer;
      this.sshObj.onCommandComplete(this.command, this.response, this.sshObj);
      if (this.sshObj.verbose) {
        this.sshObj.msg.send("" + this.sshObj.server.host + " verbose:" + this._buffer);
      }
      return this._buffer = "";
    };

    SSH2Shell.prototype._processNextCommand = function() {
      if (this.command.indexOf("sudo su") !== -1) {
        this.sshObj.exitCommands.push("exit");
      }
      if (this.command !== "exit") {
        this._processBuffer();
      }
      if (this.sshObj.commands.length > 0) {
        this.command = this.sshObj.commands.shift();
        this._processNotifications();
        if (this.command) {
          return this._runCommand();
        } else {
          return this._runExit();
        }
      } else {
        return this._runExit();
      }
    };

    SSH2Shell.prototype._runCommand = function() {
      if (this.sshObj.debug) {
        this.sshObj.msg.send("" + this.sshObj.server.host + ": next command: " + this.command);
      }
      return this._stream.write("" + this.command + "\n");
    };

    SSH2Shell.prototype._nextHost = function() {
      this._processBuffer();
      this.nextHost = this.sshObj.hosts.shift();
      if (this.sshObj.debug) {
        this.sshObj.msg.send("" + this.sshObj.server.host + ": ssh to " + this.nextHost.server.host);
      }
      this._connections.push(this.sshObj);
      if (this.sshObj.hosts.length === 0) {
        this.sshObj.exitCommands.push("exit");
      }
      this.sshObj = this.nextHost;
      this.sshObj.exitCommands = [];
      this.sshObj.pwSent = false;
      this.sshObj.sessionText = "";
      this.sshObj.sshAuth = false;
      this.command = "ssh -oStrictHostKeyChecking=no " + this.sshObj.server.userName + "@" + this.sshObj.server.host;
      return this._runCommand();
    };

    SSH2Shell.prototype._runExit = function() {
      if (this.sshObj.exitCommands && this.sshObj.exitCommands.length > 0) {
        if (this.sshObj.debug) {
          this.sshObj.msg.send("" + this.sshObj.server.host + ": Queued exit commands: " + this.sshObj.exitCommands);
        }
        this.command = this.sshObj.exitCommands.pop();
        return this._runCommand();
      } else if (this.sshObj.hosts && this.sshObj.hosts.length > 0) {
        if (this.sshObj.debug) {
          this.sshObj.msg.send("\n" + this.sshObj.server.host + ": Queued hosts for this host:");
        }
        if (this.sshObj.debug) {
          this.sshObj.msg.send(this.sshObj.hosts);
        }
        return this._nextHost();
      } else if (this._connections && this._connections.length > 0) {
        if (this.sshObj.debug) {
          this.sshObj.msg.send("\nParked hosts:");
        }
        if (this.sshObj.debug) {
          this.sshObj.msg.send(this._connections);
        }
        this.sshObj.onEnd(this.sshObj.sessionText, this.sshObj);
        this.sshObj = this._connections.pop();
        if (this.sshObj.debug) {
          this.sshObj.msg.send("loaded previous host object for: " + this.sshObj.server.host);
        }
        if (this._connections.length > 0) {
          this.sshObj.exitCommands.push("exit");
        }
        return this._processNextCommand();
      } else {
        if (this.sshObj.debug) {
          this.sshObj.msg.send("Exit and close connection on: " + this.sshObj.server.host);
        }
        return this._stream.end("exit\n");
      }
    };

    function SSH2Shell(sshObj) {
      this.sshObj = sshObj;
      this.connect = __bind(this.connect, this);
      this._runExit = __bind(this._runExit, this);
      this._nextHost = __bind(this._nextHost, this);
      this._runCommand = __bind(this._runCommand, this);
      this._processNextCommand = __bind(this._processNextCommand, this);
      this._processBuffer = __bind(this._processBuffer, this);
      this._processNotifications = __bind(this._processNotifications, this);
      this._processSSHPrompt = __bind(this._processSSHPrompt, this);
      this._processPasswordPrompt = __bind(this._processPasswordPrompt, this);
    }

    SSH2Shell.prototype.connect = function() {
      var e;
      if (this.sshObj.server && this.sshObj.commands) {
        try {
          this.connection = new require('ssh2')();
          this.connection.on("connect", (function(_this) {
            return function() {
              return _this.sshObj.msg.send(_this.sshObj.connectedMessage);
            };
          })(this));
          this.connection.on("ready", (function(_this) {
            return function() {
              _this.sshObj.msg.send(_this.sshObj.readyMessage);
              return _this.connection.shell({
                pty: true
              }, function(err, _stream) {
                _this._stream = _stream;
                if (err) {
                  _this.sshObj.msg.send("" + err);
                }
                _this.sshObj.exitCommands = [];
                _this.sshObj.pwSent = false;
                _this.sshObj.sshAuth = false;
                _this.sshObj.sessionText = "";
                _this._stream.on("error", function(error) {
                  return _this.sshObj.msg.send("Stream Error: " + error);
                });
                _this._stream.stderr.on('data', function(data) {
                  return _this.sshObj.msg.send("Stream STDERR: " + data);
                });
                _this._stream.on("readable", function() {
                  var data, e, _results;
                  try {
                    _results = [];
                    while ((data = _this._stream.read())) {
                      _this._data = "" + data;
                      _results.push(_this._processData());
                    }
                    return _results;
                  } catch (_error) {
                    e = _error;
                    return _this.sshObj.msg.send("" + e + " " + e.stack);
                  }
                });
                _this._stream.on("end", function() {
                  return _this.sshObj.onEnd(_this.sshObj.sessionText, _this.sshObj);
                });
                return _this._stream.on("close", function(code, signal) {
                  return _this.connection.end();
                });
              });
            };
          })(this));
          this.connection.on("error", (function(_this) {
            return function(err) {
              return _this.sshObj.msg.send("Connection :: error :: " + err);
            };
          })(this));
          this.connection.on("close", (function(_this) {
            return function(had_error) {
              return _this.sshObj.msg.send(_this.sshObj.closedMessage);
            };
          })(this));
          return this.connection.connect({
            host: this.sshObj.server.host,
            port: this.sshObj.server.port,
            username: this.sshObj.server.userName,
            password: this.sshObj.server.password,
            privateKey: this.sshObj.server.privateKey,
            passphrase: this.sshObj.server.passPhrase
          });
        } catch (_error) {
          e = _error;
          return this.sshObj.msg.send("" + e + " " + e.stack);
        }
      } else {
        return this.sshObj.msg.send("SSH error: missing info: server: " + this.sshObj.server.host + ", commands: " + this.sshObj.commands.length);
      }
    };

    return SSH2Shell;

  })();

  module.exports = SSH2Shell;

}).call(this);
