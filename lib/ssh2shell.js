// Generated by CoffeeScript 1.12.7
(function() {
  var SSH2Shell, Stream, typeIsArray,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  Stream = require('stream');

  SSH2Shell = (function(superClass) {
    extend(SSH2Shell, superClass);

    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype.hosts = [];

    SSH2Shell.prototype._primaryhostSessionText = "";

    SSH2Shell.prototype._allSessions = "";

    SSH2Shell.prototype._connections = [];

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype.idleTime = 5000;

    SSH2Shell.prototype.asciiFilter = "";

    SSH2Shell.prototype.textColorFilter = "";

    SSH2Shell.prototype.passwordPrompt = "";

    SSH2Shell.prototype.passphrasePrompt = "";

    SSH2Shell.prototype.standardPrompt = "";

    SSH2Shell.prototype._callback = function() {};

    SSH2Shell.prototype.onCommandProcessing = function() {};

    SSH2Shell.prototype.onCommandComplete = function() {};

    SSH2Shell.prototype.onCommandTimeout = function() {};

    SSH2Shell.prototype.onEnd = function() {};

    SSH2Shell.prototype._onData = function(data) {
      this._buffer += data;
      if (this.command.length > 0 && !this.standardPrompt.test(this._sanitizeResponse())) {
        this.emit('commandProcessing', this.command, this._buffer, this.sshObj, this._stream);
        if (this.idleTimer) {
          clearTimeout(this.idleTimer);
        }
        this.idleTimer = setTimeout((function(_this) {
          return function() {
            return _this.emit('commandTimeout', _this.command, _this._buffer, _this._stream, _this._connection);
          };
        })(this), this.idleTime);
      } else if (this.command.length < 1 && !this.standardPrompt.test(this._buffer)) {
        this.emit('commandProcessing', this.command, this._buffer, this.sshObj, this._stream);
      }
      if (this.dataReceivedTimer) {
        clearTimeout(this.dataReceivedTimer);
      }
      return this.dataReceivedTimer = setTimeout((function(_this) {
        return function() {
          if (_this.idleTimer) {
            clearTimeout(_this.idleTimer);
          }
          if (!_this.sshObj.disableColorFilter) {
            if (_this.sshObj.verbose && _this.sshObj.debug) {
              _this.emit('msg', (_this.sshObj.server.host + ": text formatting filter: ") + _this.sshObj.textColorFilter + ", filtered: " + _this.textColorFilter.test(_this._buffer));
            }
            _this._buffer = _this._buffer.replace(_this.textColorFilter, "");
          }
          if (!_this.sshObj.disableASCIIFilter) {
            if (_this.sshObj.verbose && _this.sshObj.debug) {
              _this.emit('msg', (_this.sshObj.server.host + ": Non-standard ASCII filtered: ") + _this.asciiFilter.test(_this._buffer));
            }
            _this._buffer = _this._buffer.replace(_this.asciiFilter, "");
          }
          switch (true) {
            case _this.command.length > 0 && _this.command.indexOf("sudo ") !== -1:
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Sudo command data");
              }
              return _this._processPasswordPrompt();
            case _this.command.length > 0 && _this.command.indexOf("ssh ") !== -1:
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": SSH command data");
              }
              return _this._processSSHPrompt();
            case _this.command.length > 0 && _this.standardPrompt.test(_this._sanitizeResponse()):
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Normal prompt detected");
              }
              _this.sshObj.pwSent = false;
              return _this._commandComplete();
            case _this.command.length < 1 && _this.standardPrompt.test(_this._buffer):
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": First prompt detected");
              }
              if (_this.sshObj.showBanner) {
                _this.sshObj.sessionText += _this._buffer;
              }
              return _this._nextCommand();
            default:
              if (_this.sshObj.debug) {
                _this.emit('msg', "Data processing: data received timeout");
              }
              return _this.idleTimer = setTimeout(function() {
                return _this.emit('commandTimeout', _this.command, _this._buffer, _this._stream, _this._connection);
              }, _this.idleTime);
          }
        };
      })(this), this.dataIdleTime);
    };

    SSH2Shell.prototype._sanitizeResponse = function() {
      return this._buffer.replace(this.command.substr(0, this._buffer.length), "");
    };

    SSH2Shell.prototype._processPasswordPrompt = function() {
      var passwordPrompt, response, standardPrompt;
      response = this._sanitizeResponse().trim();
      passwordPrompt = this.passwordPrompt.test(response);
      standardPrompt = this.standardPrompt.test(response);
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Sudo Password prompt detected: " + passwordPrompt);
      }
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Sudo Password prompt: Password sent: " + this.sshObj.pwSent);
      }
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Sudo Password: " + this.sshObj.server.password);
      }
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": Sudo Response: " + response);
      }
      switch (true) {
        case passwordPrompt && !this.sshObj.server.password:
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Sudo password prompt no password");
          }
          return this._resetFromSudoError();
        case passwordPrompt && !this.sshObj.pwSent:
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sudo password prompt: Buffer: " + response);
          }
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Sudo password prompt: Send password ");
          }
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sudo sent password: " + this.sshObj.server.password);
          }
          this.sshObj.pwSent = true;
          return this._runCommand("" + this.sshObj.server.password);
        case passwordPrompt && this.sshObj.pwSent:
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sudo password faied: response: " + response);
          }
          if (this.sshObj.debug) {
            this.emit('error', this.sshObj.server.host + ": Sudo password was incorrect for " + this.sshObj.server.userName + ", Sudo authentication");
          }
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Sudo failed password prompt: Password: [" + this.sshObj.server.password + "]");
          }
          this.sshObj.pwSent = false;
          return this._resetFromSudoError();
        case standardPrompt:
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Sudo prompt: Standard prompt detected");
          }
          this.sshObj.pwSent = false;
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sudo Standard Response: " + response);
          }
          return this._commandComplete();
        default:
          return this.idleTimer = setTimeout((function(_this) {
            return function() {
              return _this.emit('commandTimeout', _this.command, response, _this._stream, _this._connection);
            };
          })(this), this.idleTime);
      }
    };

    SSH2Shell.prototype._resetFromSudoError = function() {
      this.sshObj.pwSent = false;
      this.sshObj.sessionText += "" + this._buffer;
      this._buffer = "";
      this.command = "";
      return this._stream.write('\x03');
    };

    SSH2Shell.prototype._processSSHPrompt = function() {
      var passphrasePrompt, passwordPrompt, response, standardPrompt, using;
      response = this._sanitizeResponse().trim();
      if (this.idleTimer) {
        clearTimeout(this.idleTimer);
      }
      passwordPrompt = this.passwordPrompt.test(response) && !this.sshObj.server.hasOwnProperty("passPhrase");
      passphrasePrompt = this.passphrasePrompt.test(response) && this.sshObj.server.hasOwnProperty("passPhrase");
      standardPrompt = this.standardPrompt.test(response);
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": SSH: Password previously sent: " + this.sshObj.sshAuth);
      }
      if (!this.sshObj.sshAuth) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": First SSH prompt detection");
        }
        if (passwordPrompt) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH send password");
          }
          this.sshObj.sshAuth = true;
          this._buffer = "";
          return this._runCommand("" + this.sshObj.server.password);
        } else if (passphrasePrompt) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH send passphrase");
          }
          this.sshObj.sshAuth = true;
          this._buffer = "";
          return this._runCommand("" + this.sshObj.server.passPhrase);
        } else if (standardPrompt) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH standard prompt: connection failed");
          }
          this.emit('msg', this.sshObj.server.host + ": SSH connection failed");
          this.emit('msg', this.sshObj.server.host + ": SSH failed response: " + response);
          this.sshObj.sessionText += this.sshObj.server.host + ": SSH failed: response: " + response;
          return this._runExit();
        } else {
          this.emit('msg', this.sshObj.server.host + ": SSH no prompt was not detected");
          if (this.sshObj.verbose && !this.sshObj.server.hasOwnProperty("passPhrase")) {
            this.emit('msg', this.sshObj.server.host + ": SSH password prompt " + this.sshObj.passwordPrompt);
          }
          if (this.sshObj.verbose && this.sshObj.server.hasOwnProperty("passPhrase")) {
            this.emit('msg', this.sshObj.server.host + ": SSH passphrase prompt " + this.sshObj.passphrasePrompt);
          }
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": SSH standard prompt " + this.sshObj.standardPrompt);
          }
          return this._runExit();
        }
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": SSH post authentication prompt detection");
        }
        if (standardPrompt) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH complete: normal prompt");
          }
          this.sshObj.exitCommands.push("exit");
          this.emit('msg', "" + this.sshObj.connectedMessage);
          this.emit('msg', "" + this.sshObj.readyMessage);
          return this._nextCommand();
        } else if (passwordPrompt || passphrasePrompt) {
          this.emit('msg', this.sshObj.server.host + ": SSH authentication failed");
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH auth failed");
          }
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": SSH: failed response: " + response);
          }
          this.sshObj.sshAuth = false;
          using = (function() {
            switch (false) {
              case !passwordPrompt:
                return "SSH password: " + this.sshObj.server.password;
              case !passphrasePrompt:
                return "SSH passphrase: " + this.sshObj.server.passPhrase;
            }
          }).call(this);
          this.emit('error', this.sshObj.server.host + ": SSH authentication failed for " + this.sshObj.server.userName + "@" + this.sshObj.server.host, "Nested host authentication");
          if (this.sshObj.debug) {
            this.emit('msg', (this.sshObj.server.host + ": SSH auth failed: Using ") + using);
          }
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": SSH resonse: " + response);
          }
          if (this._connections.length > 0) {
            return this._previousHost();
          }
          return this._runExit();
        }
      }
    };

    SSH2Shell.prototype._processNotifications = function() {
      var msgNote, sessionNote;
      if (this.command) {
        if ((sessionNote = this.command.match(/^`(.*)`$/))) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Notifications: sessionText output");
          }
          if (this._connections.length > 0) {
            this.sshObj.sessionText += this.sshObj.server.host + ": Note: " + sessionNote[1] + this.sshObj.enter;
          } else {
            this.sshObj.sessionText += "Note: " + sessionNote[1] + this.sshObj.enter;
          }
          if (this.sshObj.verbose) {
            this.emit('msg', sessionNote[1]);
          }
          return this._nextCommand();
        } else if ((msgNote = this.command.match(/^msg:(.*)$/))) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Notifications: msg to output");
          }
          this.emit('msg', this.sshObj.server.host + ": Note: " + msgNote[1]);
          return this._nextCommand();
        } else {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Notifications: Normal Command to run");
          }
          return this._checkCommand();
        }
      }
    };

    SSH2Shell.prototype._commandComplete = function() {
      var response;
      response = this._buffer.trim();
      if (this.command !== "" && this.command !== "exit" && this.command.indexOf("ssh ") === -1) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Command complete:\nCommand:\n " + this.command + "\nResponse: " + response);
        }
        this.sshObj.sessionText += response;
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Raising commandComplete event");
        }
        this.emit('commandComplete', this.command, this._buffer, this.sshObj);
      }
      return this._nextCommand();
    };

    SSH2Shell.prototype._nextCommand = function() {
      this._buffer = "";
      if (this.sshObj.commands.length > 0) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Host.commands: " + this.sshObj.commands);
        }
        this.command = this.sshObj.commands.shift();
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Next command from host.commands: " + this.command);
        }
        return this._processNotifications();
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": No commands so exit");
        }
        return this._runExit();
      }
    };

    SSH2Shell.prototype._checkCommand = function() {
      if (this.command !== "") {
        return this._runCommand(this.command);
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": No command so exit");
        }
        return this._runExit();
      }
    };

    SSH2Shell.prototype._runCommand = function(command) {
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": sending: " + command);
      }
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": run command");
      }
      return this._stream.write("" + command + this.sshObj.enter);
    };

    SSH2Shell.prototype._previousHost = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Load previous host config");
      }
      this.emit('end', this.sshObj.server.host + ": \n" + this.sshObj.sessionText, this.sshObj);
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Previous hosts: " + this._connections.length);
      }
      if (this._connections.length > 0) {
        this.sshObj = this._connections.pop();
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Reload previous host");
        }
        return this._loadDefaults(this._runExit);
      } else {
        return this._runExit();
      }
    };

    SSH2Shell.prototype._nextHost = function() {
      var nextHost;
      nextHost = this.sshObj.hosts.shift();
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": SSH to " + nextHost.server.host);
      }
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Clearing previous event handlers");
      }
      this._connections.push(this.sshObj);
      this.sshObj = nextHost;
      return this._initiate(this._sshConnect);
    };

    SSH2Shell.prototype._nextPrimaryHost = function(callback) {
      if (typeIsArray(this.hosts) && this.hosts.length > 0) {
        if (this.sshObj.server) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Current primary host");
          }
        }
        this.sshObj = this.hosts.shift();
        this._primaryhostSessionText = this.sshObj.server.host + ": ";
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Next primary host");
        }
        return this._initiate(callback);
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": No more primary hosts");
        }
        return this._runExit;
      }
    };

    SSH2Shell.prototype._sshConnect = function() {
      var option, ref, sshFlags, sshOptions, value;
      sshFlags = "-x";
      sshOptions = "";
      if (this.sshObj.server.ssh) {
        if (this.sshObj.server.ssh.forceProtocolVersion) {
          sshFlags += this.sshObj.server.ssh.forceProtocolVersion;
        }
        if (this.sshObj.server.ssh.forceAddressType) {
          sshFlags += this.sshObj.server.ssh.forceAddressType;
        }
        if (this.sshObj.server.ssh.disablePseudoTTY) {
          sshFlags += "T";
        }
        if (this.sshObj.server.ssh.forcePseudoTTY) {
          sshFlags += "t";
        }
        if (this.sshObj.server.ssh.verbose) {
          sshFlags += "v";
        }
        if (this.sshObj.server.ssh.cipherSpec) {
          sshOptions += " -c " + this.sshObj.server.ssh.cipherSpec;
        }
        if (this.sshObj.server.ssh.escape) {
          sshOptions += " -e " + this.sshObj.server.ssh.escape;
        }
        if (this.sshObj.server.ssh.logFile) {
          sshOptions += " -E " + this.sshObj.server.ssh.logFile;
        }
        if (this.sshObj.server.ssh.configFile) {
          sshOptions += " -F " + this.sshObj.server.ssh.configFile;
        }
        if (this.sshObj.server.ssh.identityFile) {
          sshOptions += " -i " + this.sshObj.server.ssh.identityFile;
        }
        if (this.sshObj.server.ssh.loginName) {
          sshOptions += " -l " + this.sshObj.server.ssh.loginName;
        }
        if (this.sshObj.server.ssh.macSpec) {
          sshOptions += " -m " + this.sshObj.server.ssh.macSpec;
        }
        ref = this.sshObj.server.ssh.Options;
        for (option in ref) {
          value = ref[option];
          sshOptions += ' -o "#{option}={#value}"';
        }
      }
      sshOptions += ' -o "StrictHostKeyChecking=no"';
      sshOptions += " -p " + this.sshObj.server.port;
      this.sshObj.sshAuth = false;
      this.command = "ssh " + sshFlags + " " + sshOptions + " " + this.sshObj.server.userName + "@" + this.sshObj.server.host;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": SSH command: connect");
      }
      return this._runCommand(this.command);
    };

    SSH2Shell.prototype._runExit = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Process an exit");
      }
      if (this.sshObj.exitCommands && this.sshObj.exitCommands.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Queued exit commands: " + this.sshObj.exitCommands.length);
        }
        this.command = this.sshObj.exitCommands.pop();
        if (this._connections && this._connections.length > 0) {
          this._connections[0].sessionText += "\n" + this.sshObj.server.host + ": " + this.sshObj.sessionText;
        }
        return this._runCommand(this.command);
      } else if (this.sshObj.hosts && this.sshObj.hosts.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Next host from this host");
        }
        return this._nextHost();
      } else if (this._connections && this._connections.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": load previous host");
        }
        this.emit('msg', this.sshObj.server.host + ": " + this.sshObj.closedMessage);
        return this._previousHost();
      } else if (this.command === "exit") {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Manual exit command");
        }
        return this._runCommand("exit");
      } else {
        return this.close();
      }
    };

    SSH2Shell.prototype.close = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Exit command: Stream: close");
      }
      return this._stream.close();
    };

    SSH2Shell.prototype._removeEvents = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Clearing host event handlers");
      }
      this.removeAllListeners('keyboard-interactive');
      this.removeAllListeners("error");
      if (typeof this.sshObj.onData === 'function') {
        this.removeListener("data", this.sshObj.onData);
      }
      if (typeof this.sshObj.onStderrData === 'function') {
        this.removeListener("stderrData", this.sshObj.onStderrData);
      }
      this.removeAllListeners('end');
      this.removeAllListeners('commandProcessing');
      this.removeAllListeners('commandComplete');
      this.removeAllListeners('commandTimeout');
      this.removeAllListeners('msg');
      if (this.idleTimer) {
        clearTimeout(this.idleTimer);
      }
      if (this.dataReceivedTimer) {
        return clearTimeout(this.dataReceivedTimer);
      }
    };

    function SSH2Shell(hosts) {
      this._connect = bind(this._connect, this);
      this.connect = bind(this.connect, this);
      this._loadDefaults = bind(this._loadDefaults, this);
      this._initiate = bind(this._initiate, this);
      this._removeEvents = bind(this._removeEvents, this);
      this.close = bind(this.close, this);
      this._runExit = bind(this._runExit, this);
      this._sshConnect = bind(this._sshConnect, this);
      this._nextPrimaryHost = bind(this._nextPrimaryHost, this);
      this._nextHost = bind(this._nextHost, this);
      this._previousHost = bind(this._previousHost, this);
      this._runCommand = bind(this._runCommand, this);
      this._checkCommand = bind(this._checkCommand, this);
      this._nextCommand = bind(this._nextCommand, this);
      this._commandComplete = bind(this._commandComplete, this);
      this._processNotifications = bind(this._processNotifications, this);
      this._processSSHPrompt = bind(this._processSSHPrompt, this);
      this._resetFromSudoError = bind(this._resetFromSudoError, this);
      this._processPasswordPrompt = bind(this._processPasswordPrompt, this);
      this._sanitizeResponse = bind(this._sanitizeResponse, this);
      this._onData = bind(this._onData, this);
      this.onEnd = bind(this.onEnd, this);
      this.onCommandTimeout = bind(this.onCommandTimeout, this);
      this.onCommandComplete = bind(this.onCommandComplete, this);
      this.onCommandProcessing = bind(this.onCommandProcessing, this);
      this._callback = bind(this._callback, this);
      if (typeIsArray(hosts)) {
        this.hosts = hosts;
      } else {
        this.hosts = [hosts];
      }
      this.ssh2Client = require('ssh2').Client;
      this.on("newPrimmaryHost", this._nextPrimaryHost);
      this.on("data", (function(_this) {
        return function(data) {
          return _this._onData(data);
        };
      })(this));
      this.on("stderrData", (function(_this) {
        return function(data) {
          return console.error(data);
        };
      })(this));
      this._allSessions = "";
    }

    SSH2Shell.prototype._initiate = function(callback) {
      this._removeEvents();
      if (this.sshObj.msg && this.sshObj.msg.send && typeof this.sshObj.msg.send === 'function') {
        this.on("msg", this.sshObj.msg.send);
      } else if (typeof this.sshObj.msg === 'function') {
        this.on("msg", this.sshObj.msg);
      } else {
        this.on("msg", (function(_this) {
          return function(message) {
            return console.log(message);
          };
        })(this));
      }
      this._loadDefaults();
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": initiate");
      }
      this.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          var str;
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.keyboard-interactive");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', "name: " + name);
            _this.emit('msg', "instructions: " + instructions);
            str = JSON.stringify(prompts, null, 4);
            return _this.emit('msg', "Prompts object: " + str);
          }
        };
      })(this));
      this.on("error", (function(_this) {
        return function(err, type, close, callback) {
          if (close == null) {
            close = false;
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.error");
          }
          if (err instanceof Error) {
            _this.emit('msg', "Error: " + err.message + ", Level: " + err.level);
          } else {
            _this.emit('msg', (type + " error: ") + err);
          }
          if (typeof callback === 'function') {
            callback(err, type);
          }
          if (close) {
            return _this.connection.end();
          }
        };
      })(this));
      this.on("end", (function(_this) {
        return function(sessionText, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.end");
          }
        };
      })(this));
      if (typeof callback === 'function') {
        return callback();
      }
    };

    SSH2Shell.prototype._loadDefaults = function(callback) {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Load Defaults");
      }
      this.command = "";
      this._buffer = "";
      if (!this.sshObj.connectedMessage) {
        this.sshObj.connectedMessage = "Connected";
      }
      if (!this.sshObj.readyMessage) {
        this.sshObj.readyMessage = "Ready";
      }
      if (!this.sshObj.closedMessage) {
        this.sshObj.closedMessage = "Closed";
      }
      if (!this.sshObj.showBanner) {
        this.sshObj.showBanner = false;
      }
      if (!this.sshObj.verbose) {
        this.sshObj.verbose = false;
      }
      if (!this.sshObj.debug) {
        this.sshObj.debug = false;
      }
      if (!this.sshObj.hosts) {
        this.sshObj.hosts = [];
      }
      if (!this.sshObj.commands) {
        this.sshObj.commands = [];
      }
      if (!this.sshObj.standardPrompt) {
        this.sshObj.standardPrompt = ">$%#";
      }
      if (!this.sshObj.passwordPrompt) {
        this.sshObj.passwordPrompt = this.sshObj.passwordPromt;
      }
      if (!this.sshObj.passphrasePrompt) {
        this.sshObj.passphrasePrompt = this.sshObj.passphrasePromt;
      }
      if (!this.sshObj.passwordPrompt) {
        this.sshObj.passwordPrompt = ":";
      }
      if (!this.sshObj.passphrasePrompt) {
        this.sshObj.passphrasePrompt = ":";
      }
      if (!this.sshObj.passPromptText) {
        this.sshObj.passPromptText = "Password";
      }
      if (!this.sshObj.enter) {
        this.sshObj.enter = "\n";
      }
      if (!this.sshObj.asciiFilter) {
        this.sshObj.asciiFilter = "[^\r\n\x20-\x7e]";
      }
      if (this.sshObj.disableColorFilter !== true) {
        this.sshObj.disableColorFilter = false;
      }
      if (this.sshObj.disableASCIIFilter !== true) {
        this.sshObj.disableASCIIFilter = false;
      }
      if (!this.sshObj.textColorFilter) {
        this.sshObj.textColorFilter = "(\[{1}[0-9;]+m{1})";
      }
      if (!this.sshObj.exitCommands) {
        this.sshObj.exitCommands = [];
      }
      this.sshObj.pwSent = false;
      this.sshObj.sshAuth = false;
      this.sshObj.server.hashKey = (ref = this.sshObj.server.hashKey) != null ? ref : "";
      if (!this.sshObj.sessionText) {
        this.sshObj.sessionText = "";
      }
      this.sshObj.streamEncoding = (ref1 = this.sshObj.streamEncoding) != null ? ref1 : "utf8";
      if (!this.sshObj.window) {
        this.sshObj.window = true;
      }
      if (!this.sshObj.pty) {
        this.sshObj.pty = true;
      }
      this.idleTime = (ref2 = this.sshObj.idleTimeOut) != null ? ref2 : 5000;
      this.dataIdleTime = (ref3 = this.sshObj.dataIdleTime) != null ? ref3 : 500;
      if (!this.asciiFilter) {
        this.asciiFilter = new RegExp(this.sshObj.asciiFilter, "g");
      }
      if (!this.textColorFilter) {
        this.textColorFilter = new RegExp(this.sshObj.textColorFilter, "g");
      }
      if (!this.passwordPrompt) {
        this.passwordPrompt = new RegExp(this.sshObj.passPromptText + ".*" + this.sshObj.passwordPrompt + "\\s?$", "i");
      }
      if (!this.passphrasePrompt) {
        this.passphrasePrompt = new RegExp(this.sshObj.passPromptText + ".*" + this.sshObj.passphrasePrompt + "\\s?$", "i");
      }
      if (!this.standardPrompt) {
        this.standardPrompt = new RegExp("[" + this.sshObj.standardPrompt + "]\\s?$");
      }
      this.sshObj.onCommandProcessing = (ref4 = this.sshObj.onCommandProcessing) != null ? ref4 : (function(_this) {
        return function(command, response, sshObj, stream) {};
      })(this);
      this.sshObj.onCommandComplete = (ref5 = this.sshObj.onCommandComplete) != null ? ref5 : (function(_this) {
        return function(command, response, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.commandComplete");
          }
        };
      })(this);
      this.sshObj.onCommandTimeout = (ref6 = this.sshObj.onCommandTimeout) != null ? ref6 : (function(_this) {
        return function(command, response, stream, connection) {
          response = response.replace(_this.command, "");
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.commandTimeout");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', _this.sshObj.server.host + ": Timeout command: " + command + " response: " + response);
          }
          _this._runExit();
          return _this.emit("error", _this.sshObj.server.host + ": Command timed out after " + (_this.idleTime / 1000) + " seconds", "Timeout", true, function(err, type) {
            return _this.sshObj.sessionText += _this._buffer;
          });
        };
      })(this);
      if (typeof this.sshObj.onKeyboardInteractive === 'function') {
        this.on("keyboard-interactive", this.sshObj.onKeyboardInteractive);
      }
      if (typeof this.sshObj.onError === 'function') {
        this.on("error", this.sshObj.onError);
      }
      if (typeof this.sshObj.onData === 'function') {
        this.on("data", this.sshObj.onData);
      }
      if (typeof this.sshObj.onStderrData === 'function') {
        this.on("stderrData", this.sshObj.onStderrData);
      }
      this.on("commandProcessing", this.sshObj.onCommandProcessing);
      this.on("commandComplete", this.sshObj.onCommandComplete);
      this.on("commandTimeout", this.sshObj.onCommandTimeout);
      if (typeof this.sshObj.onEnd === 'function') {
        this.on("end", this.sshObj.onEnd);
      }
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": Host loaded");
      }
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj);
      }
      if (typeof callback === 'function') {
        return callback();
      }
    };

    SSH2Shell.prototype.connect = function(callback) {
      if (typeof callback === 'function') {
        this._callback = callback;
      }
      return this.emit("newPrimaryHost", this._nextPrimaryHost(this._connect));
    };

    SSH2Shell.prototype._connect = function() {
      var e;
      this.connection = new this.ssh2Client();
      this.connection.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.keyboard-interactive");
          }
          return _this.emit("keyboard-interactive", name, instructions, instructionsLang, prompts, finish);
        };
      })(this));
      this.connection.on("connect", (function(_this) {
        return function() {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.connect");
          }
          return _this.emit('msg', _this.sshObj.connectedMessage);
        };
      })(this));
      this.connection.on("ready", (function(_this) {
        return function() {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.ready");
          }
          _this.emit('msg', _this.sshObj.readyMessage);
          return _this.connection.shell(_this.sshObj.window, {
            pty: _this.sshObj.pty
          }, function(err, _stream) {
            _this._stream = _stream;
            if (err instanceof Error) {
              _this.emit('error', err, "Shell", true);
              return;
            }
            if (_this.sshObj.debug) {
              _this.emit('msg', _this.sshObj.server.host + ": Connection.shell");
            }
            _this._stream.setEncoding(_this.sshObj.streamEncoding);
            _this._stream.on("error", function(err) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.error");
              }
              return _this.emit('error', err, "Stream");
            });
            _this._stream.stderr.on('data', function(data) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.stderr.data");
              }
              return _this.emit('stderrData', data);
            });
            _this._stream.on("data", function(data) {
              var e;
              try {
                return _this.emit('data', data);
              } catch (error) {
                e = error;
                err = new Error(e + " " + e.stack);
                err.level = "Data handling";
                return _this.emit('error', err, "Stream.read", true);
              }
            });
            _this._stream.on("finish", function() {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.finish");
              }
              _this._primaryhostSessionText += _this.sshObj.sessionText + "\n";
              _this._allSessions += _this._primaryhostSessionText;
              if (typeIsArray(_this.hosts) && _this.hosts.length === 0) {
                _this.emit('end', _this._allSessions, _this.sshObj);
              }
              return _this._removeEvents();
            });
            return _this._stream.on("close", function(code, signal) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.close");
              }
              return _this.connection.end();
            });
          });
        };
      })(this));
      this.connection.on("error", (function(_this) {
        return function(err) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.error");
          }
          return _this.emit("error", err, "Connection");
        };
      })(this));
      this.connection.on("close", (function(_this) {
        return function(had_error) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.close");
          }
          if (had_error) {
            _this.emit("error", had_error, "Connection close");
          } else {
            _this.emit('msg', _this.sshObj.closedMessage);
          }
          if (typeIsArray(_this.hosts) && _this.hosts.length === 0) {
            if (typeof _this._callback === 'function') {
              return _this._callback(_this._allSessions);
            }
          } else {
            return _this.emit("newPrimaryHost", _this._nextPrimaryHost(_this._connect));
          }
        };
      })(this));
      if (this.sshObj.server && this.sshObj.commands) {
        try {
          if (!this.sshObj.server.username) {
            this.sshObj.server.username = this.sshObj.server.userName;
          }
          if (!this.sshObj.server.hostHash) {
            this.sshObj.server.hostHash = this.sshObj.server.hashMethod;
          }
          if (!this.sshObj.server.passphrase) {
            this.sshObj.server.passphrase = this.sshObj.server.passPhrase;
          }
          this.connection.connect(this.sshObj.server);
        } catch (error) {
          e = error;
          this.emit('error', e + " " + e.stack, "Connection.connect", true);
        }
      } else {
        this.emit('error', "Missing connection parameters", "Parameters", false, function(err, type, close) {
          this.emit('msg', this.sshObj.server);
          return this.emit('msg', this.sshObj.commands);
        });
      }
      return this._stream;
    };

    return SSH2Shell;

  })(Stream);

  module.exports = SSH2Shell;

}).call(this);
