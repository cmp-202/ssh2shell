// Generated by CoffeeScript 1.8.0
(function() {
  var SSH2Shell,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  SSH2Shell = (function() {
    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.stream = {};

    SSH2Shell.prototype.sessionText = "";

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype.response = "";

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype._pwSent = false;

    SSH2Shell.prototype._sudosu = false;

    SSH2Shell.prototype._exit = false;

    SSH2Shell.prototype._processData = function() {
      this._data = this._data.replace(/[^\r\n\x20-\x7e]/g, "");
      this._data = this._data.replace(/(\[[0-9]?[0-9]m)/g, "");
      this._buffer += "" + this._data;
      if (this.command.indexOf("sudo") !== -1) {
        return this._processPasswordPrompt();
      } else if (this._buffer.match(/[#$]\s$/)) {
        return this._processNextCommand;
      } else {
        this._processBuffer;
        return this.sshObj.onCommandProcessing(this.command, this._buffer, this.sshObj, this.stream);
      }
    };

    SSH2Shell.prototype._processPasswordPrompt = function() {
      var password;
      if (this._pwSent === false) {
        if (this._buffer.match(/password.*:\s$/i)) {
          if (this.command.indexOf("sudo su") !== -1) {
            this._sudosu = true;
          }
          this._pwSent = true;
          password = this.sshObj.server.sudoPassword !== '' ? this.sshObj.server.sudoPassword : this.sshObj.server.password;
          return this.stream.write("" + password + "\n");
        }
      } else {
        if (this._buffer.match(/password.*:\s$/i)) {
          this.sshObj.msg.send("Error: Sudo password was incorrect session is closing");
          if (this.sshObj.verbose) {
            password = this.sshObj.server.sudoPassword !== '' ? this.sshObj.server.sudoPassword : this.sshObj.server.password;
            this.sshObj.msg.send("password: " + password);
          }
          this.sessionText += "" + this._buffer;
          return this.connection.end();
        } else if (this._buffer.match(/[#$]\s$/)) {
          return this._processNextCommand;
        }
      }
    };

    SSH2Shell.prototype._processBuffer = function() {
      this.sessionText += "" + this._buffer;
      this.response = this._buffer;
      this.sshObj.onCommandComplete(this.command, this.response, this.sshObj);
      if (this.sshObj.verbose) {
        this.sshObj.msg.send(this._buffer);
      }
      return this._buffer = "";
    };

    SSH2Shell.prototype._processNotifications = function() {
      var msgNote, sessionNote, _results;
      _results = [];
      while (this.command && ((sessionNote = this.command.match(/^`(.*)`$/)) || (msgNote = this.command.match(/^msg:(.*)$/)))) {
        if (sessionNote) {
          this.sessionText += "" + sessionNote[1] + "\n";
          if (this.sshObj.verbose) {
            this.sshObj.msg.send(this.command.replace(/`/g, ""));
          }
        } else if (msgNote) {
          if (!this.sshObj.verbose) {
            this.sshObj.msg.send(msgNote[1]);
          }
        }
        _results.push(this.command = this.sshObj.commands.shift());
      }
      return _results;
    };

    SSH2Shell.prototype._processNextCommand = function() {
      if (!this._exit) {
        this._processBuffer();
      }
      if (this.sshObj.commands.length > 0) {
        this.command = this.sshObj.commands.shift();
        this._processNotifications();
        if (this.command) {
          return this.stream.write("" + this.command + "\n");
        } else {
          return this._runExit();
        }
      } else {
        return this._runExit();
      }
    };

    SSH2Shell.prototype._runExit = function() {
      this._exit = true;
      this.command = "exit\n";
      if (this._sudosu) {
        this.stream.write("exit\n");
        return this._sudosu = false;
      } else {
        return this.stream.end("exit\n");
      }
    };

    function SSH2Shell(sshObj) {
      this.sshObj = sshObj;
      this.connect = __bind(this.connect, this);
      this._runExit = __bind(this._runExit, this);
      this._processNextCommand = __bind(this._processNextCommand, this);
      this._processNotifications = __bind(this._processNotifications, this);
      this._processBuffer = __bind(this._processBuffer, this);
      this._processPasswordPrompt = __bind(this._processPasswordPrompt, this);
    }

    SSH2Shell.prototype.connect = function() {
      var e;
      if (this.sshObj.server && this.sshObj.commands) {
        try {
          this.connection = new require('ssh2')();
          this.connection.on("connect", (function(_this) {
            return function() {
              return _this.sshObj.msg.send(_this.sshObj.connectedMessage);
            };
          })(this));
          this.connection.on("ready", (function(_this) {
            return function() {
              _this.sshObj.msg.send(_this.sshObj.readyMessage);
              return _this.connection.shell(function(err, stream) {
                _this.stream = stream;
                if (err) {
                  _this.sshObj.msg.send("" + err);
                }
                _this.stream.on("error", function(error) {
                  return _this.sshObj.msg.send("Stream Error: " + error);
                });
                _this.stream.stderr.on('data', function(data) {
                  return _this.sshObj.msg.send("Stream STDERR: " + data);
                });
                _this.stream.on("readable", function() {
                  var data, e, _results;
                  try {
                    _results = [];
                    while ((data = _this.stream.read())) {
                      _this._data = "" + data;
                      _results.push(_this._processData());
                    }
                    return _results;
                  } catch (_error) {
                    e = _error;
                    return _this.sshObj.msg.send("" + e + " " + e.stack);
                  }
                });
                _this.stream.on("end", function() {
                  return _this.sshObj.onEnd(_this.sessionText, _this.sshObj);
                });
                _this.stream.on("close", function(code, signal) {
                  return _this.connection.end();
                });
                _this.command = _this.sshObj.commands.shift();
                _this._processNotifications();
                return _this.stream.write("" + _this.command + "\n");
              });
            };
          })(this));
          this.connection.on("error", (function(_this) {
            return function(err) {
              return _this.sshObj.msg.send("Connection :: error :: " + err);
            };
          })(this));
          this.connection.on("close", (function(_this) {
            return function(had_error) {
              return _this.sshObj.msg.send(_this.sshObj.closedMessage);
            };
          })(this));
          if (this.sshObj.server.privateKey) {
            return this.connection.connect({
              host: this.sshObj.server.host,
              port: this.sshObj.server.port,
              username: this.sshObj.server.userName,
              privateKey: this.sshObj.server.privateKey,
              passphrase: this.sshObj.server.passPhrase
            });
          } else {
            return this.connection.connect({
              host: this.sshObj.server.host,
              port: this.sshObj.server.port,
              username: this.sshObj.server.userName,
              password: this.sshObj.server.password
            });
          }
        } catch (_error) {
          e = _error;
          return this.sshObj.msg.send("" + e + " " + e.stack);
        }
      } else {
        return this.sshObj.msg.send("SSH error: missing info: server: " + this.sshObj.server.host + ", commands: " + this.sshObj.commands.length);
      }
    };

    return SSH2Shell;

  })();

  module.exports = SSH2Shell;

}).call(this);
