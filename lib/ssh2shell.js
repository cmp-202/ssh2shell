// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter, SSH2Shell,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  SSH2Shell = (function(superClass) {
    extend(SSH2Shell, superClass);

    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype._connections = [];

    SSH2Shell.prototype._timedout = function() {
      return this.emit('commandTimeout', this.command, this._buffer, this._stream, this.connection);
    };

    SSH2Shell.prototype._processData = function(data) {
      data = data.replace(/[^\r\n\x20-\x7e]/g, "");
      data = data.replace(/(\[[0-9]?[0-9][a-zA-Z])/g, "");
      this._buffer += data;
      if (this.command && this.command.indexOf("sudo ") !== -1) {
        return this._processPasswordPrompt();
      } else if (this.command && this.command.indexOf("ssh ") !== -1) {
        return this._processSSHPrompt();
      } else if (this.standardPromt.test(this._buffer)) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": normal prompt");
        }
        return this._processNextCommand();
      } else {
        this.emit('commandProcessing', this.command, this._buffer, this.sshObj, this._stream);
        if (this._idleTimer) {
          clearTimeout(this._idleTimer);
        }
        return this._idleTimer = setTimeout(this._timedout, this._idleTime);
      }
    };

    SSH2Shell.prototype._processPasswordPrompt = function() {
      if (!this.sshObj.pwSent) {
        if (this.passwordPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Send password [" + this.sshObj.server.password + "]");
          }
          this.sshObj.pwSent = true;
          return this._stream.write(this.sshObj.server.password + "\n");
        } else if (this.standardPromt.test(this._buffer)) {
          return this._processNextCommand();
        }
      } else if (this.standardPromt.test(this._buffer)) {
        return this._processNextCommand();
      } else {
        if (this.passwordPromt.test(this._buffer)) {
          this.emit('msg', this.sshObj.server.host + ": Error: Sudo password was incorrect for " + this.sshObj.server.userName + ", leaving host.");
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": password: [" + this.sshObj.server.password + "]");
          }
          this.sshObj.sessionText += "" + this._buffer;
          this._buffer = "";
          this.sshObj.commands = [];
          return this._stream.write('\x03');
        }
      }
    };

    SSH2Shell.prototype._processSSHPrompt = function() {
      var password;
      if (!this.sshObj.sshAuth) {
        if (this.passwordPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": ssh password prompt");
          }
          this.sshObj.sshAuth = true;
          return this._stream.write(this.sshObj.server.password + "\n");
        } else if (this.passphrasePromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": ssh passphrase prompt");
          }
          this.sshObj.sshAuth = "true";
          return this._stream.write(this.sshObj.server.passPhrase + "\n");
        } else if (this.standardPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', "ssh auth normal prompt");
          }
          this.sshObj.sshAuth = true;
          this.sshObj.sessionText += "Connected to " + this.sshObj.server.host + "\n";
          return this._processNextCommand();
        }
      } else {
        if ((password = this.passwordPromt.test(this._buffer) || this.passphrasePromt.test(this._buffer))) {
          this.sshObj.sshAuth = false;
          this.emit('msg', "Error: SSH authentication failed for " + this.sshObj.server.userName + "@" + this.sshObj.server.host);
          if (this.sshObj.debug) {
            this.emit('msg', "Using " + (password ? "password: [" + this.sshObj.server.password + "]" : "passphrase: [" + this.sshObj.server.passPhrase + "]"));
          }
          if (this._connections.length > 0) {
            this.sshObj = this._connections.pop();
          }
          this.sshObj.sessionText += "" + this._buffer;
          return this._stream.write('\x03');
        } else if (this.passwordPromt.test(this._buffer)) {
          if (this.sshObj.debug) {
            this.emit('msg', "ssh normal prompt");
          }
          this.sshObj.sessionText += "Connected to " + this.sshObj.server.host + "\n";
          return this._processNextCommand();
        }
      }
    };

    SSH2Shell.prototype._processNotifications = function() {
      var msgNote, results, sessionNote;
      results = [];
      while (this.command && ((sessionNote = this.command.match(/^`(.*)`$/)) || (msgNote = this.command.match(/^msg:(.*)$/)))) {
        if (sessionNote) {
          this.sshObj.sessionText += this.sshObj.server.host + ": " + sessionNote[1] + "\n";
          if (this.sshObj.verbose) {
            this.emit('msg', sessionNote[1]);
          }
        } else if (msgNote) {
          this.emit('msg', this.sshObj.server.host + ": " + msgNote[1]);
        }
        if (this.sshObj.commands.length > 0) {
          results.push(this.command = this.sshObj.commands.shift());
        } else {
          results.push(this.command = false);
        }
      }
      return results;
    };

    SSH2Shell.prototype._processNextCommand = function() {
      if (this.command.indexOf("sudo su") !== -1) {
        this.sshObj.exitCommands.push("exit");
      }
      if (this.command !== "" && this.command !== "exit" && this.command.indexOf("ssh ") === -1) {
        this.sshObj.sessionText += this._buffer;
      }
      this.emit('commandComplete', this.command, this._buffer, this.sshObj);
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + " verbose:" + this._buffer);
      }
      this._buffer = "";
      if (this.sshObj.commands.length > 0) {
        this.command = this.sshObj.commands.shift();
        this._processNotifications();
        if (this.command) {
          return this._runCommand();
        } else {
          return this._runExit();
        }
      } else {
        return this._runExit();
      }
    };

    SSH2Shell.prototype._runCommand = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": next command: " + this.command);
      }
      return this._stream.write(this.command + "\n");
    };

    SSH2Shell.prototype._nextHost = function() {
      this._buffer = "";
      this.nextHost = this.sshObj.hosts.shift();
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": ssh to " + this.nextHost.server.host);
      }
      this._connections.push(this.sshObj);
      this.sshObj = this.nextHost;
      this._loadDefaults();
      if (this.sshObj.hosts && this.sshObj.hosts.length === 0) {
        this.sshObj.exitCommands.push("exit");
      }
      this.sshObj.commands.unshift("ssh -oStrictHostKeyChecking=no " + this.sshObj.server.userName + "@" + this.sshObj.server.host);
      return this._processNextCommand();
    };

    SSH2Shell.prototype._runExit = function() {
      if (this.sshObj.exitCommands && this.sshObj.exitCommands.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Queued exit commands: " + this.sshObj.exitCommands);
        }
        this.command = this.sshObj.exitCommands.pop();
        return this._runCommand();
      } else if (this.sshObj.hosts && this.sshObj.hosts.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', "\n" + this.sshObj.server.host + ": Queued hosts for this host:");
        }
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.hosts);
        }
        return this._nextHost();
      } else if (this._connections && this._connections.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', "\nParked hosts:");
        }
        if (this.sshObj.debug) {
          this.emit('msg', this._connections);
        }
        this.emit('end', this.sshObj.sessionText, this.sshObj);
        this.sshObj = this._connections.pop();
        if (this.sshObj.debug) {
          this.emit('msg', "loaded previous host object for: " + this.sshObj.server.host);
        }
        if (this._connections.length > 0) {
          this.sshObj.exitCommands.push("exit");
        }
        return this._processNextCommand();
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', "Exit and close connection on: " + this.sshObj.server.host);
        }
        return this._stream.end("exit\n");
      }
    };

    SSH2Shell.prototype._loadDefaults = function() {
      var ref;
      if (!this.sshObj.msg) {
        this.sshObj.msg = {
          send: (function(_this) {
            return function(message) {
              return console.log(message);
            };
          })(this)
        };
      }
      if (!this.sshObj.connectedMessage) {
        this.sshObj.connectedMessage = "Connected";
      }
      if (!this.sshObj.readyMessage) {
        this.sshObj.readyMessage = "Ready";
      }
      if (!this.sshObj.closedMessage) {
        this.sshObj.closedMessage = "Closed";
      }
      if (!this.sshObj.verbose) {
        this.sshObj.verbose = false;
      }
      if (!this.sshObj.debug) {
        this.sshObj.debug = false;
      }
      if (!this.sshObj.hosts) {
        this.sshObj.hosts = [];
      }
      if (!this.sshObj.standardPrompt) {
        this.sshObj.standardPrompt = ">$%#";
      }
      if (!this.sshObj.passwordPromt) {
        this.sshObj.passwordPromt = ":";
      }
      if (!this.sshObj.passphrasePromt) {
        this.sshObj.passphrasePromt = ":";
      }
      this.sshObj.exitCommands = [];
      this.sshObj.pwSent = false;
      this.sshObj.sshAuth = false;
      this._idleTime = (ref = this.sshObj.idleTimeOut) != null ? ref : 5000;
      this.passwordPromt = new RegExp("password.*" + this.sshObj.passwordPromt + "\\s$", "i");
      this.passphrasePromt = new RegExp("password.*" + this.sshObj.passphrasePromt + "\\s$", "i");
      return this.standardPromt = new RegExp("[" + this.sshObj.standardPrompt + "]\\s$");
    };

    function SSH2Shell(sshObj1) {
      this.sshObj = sshObj1;
      this.connect = bind(this.connect, this);
      this._loadDefaults = bind(this._loadDefaults, this);
      this._runExit = bind(this._runExit, this);
      this._nextHost = bind(this._nextHost, this);
      this._runCommand = bind(this._runCommand, this);
      this._processNextCommand = bind(this._processNextCommand, this);
      this._processNotifications = bind(this._processNotifications, this);
      this._processSSHPrompt = bind(this._processSSHPrompt, this);
      this._processPasswordPrompt = bind(this._processPasswordPrompt, this);
      this._processData = bind(this._processData, this);
      this._timedout = bind(this._timedout, this);
      this._loadDefaults();
      this.connection = new require('ssh2')();
      this.on("connect", (function(_this) {
        return function() {
          return _this.emit('msg', _this.sshObj.connectedMessage);
        };
      })(this));
      this.on("ready", (function(_this) {
        return function() {
          return _this.emit('msg', _this.sshObj.readyMessage);
        };
      })(this));
      this.on("msg", (function(_this) {
        return function(message) {
          if (_this.sshObj.msg) {
            return _this.sshObj.msg.send(message);
          }
        };
      })(this));
      this.on('commandProcessing', (function(_this) {
        return function(command, response, sshObj, stream) {
          if (_this.sshObj.onCommandProcessing) {
            return _this.sshObj.onCommandProcessing(command, response, sshObj, stream);
          }
        };
      })(this));
      this.on('commandComplete', (function(_this) {
        return function(command, response, sshObj) {
          if (_this.sshObj.onCommandComplete) {
            return _this.sshObj.onCommandComplete(command, response, sshObj);
          }
        };
      })(this));
      this.on('commandTimeout', (function(_this) {
        return function(command, response, stream, connection) {
          if (_this.sshObj.onCommandTimeout) {
            return _this.sshObj.onCommandTimeout(command, response, stream, connection);
          } else {
            return _this.emit("error", _this.sshObj.server.host + ": Command timed out after " + (_this._idleTime / 1000) + " seconds", "Timeout", true, function(err, type) {
              return _this.sshObj.sessionText += _this._buffer;
            });
          }
        };
      })(this));
      this.on('end', (function(_this) {
        return function(sessionText, sshObj) {
          if (_this.sshObj.onEnd) {
            return _this.sshObj.onEnd(sessionText, sshObj);
          }
        };
      })(this));
      this.on("close", (function(_this) {
        return function(had_error) {
          if (had_error) {
            return _this.emit("error", had_error, "Close");
          } else {
            return _this.emit('msg', _this.sshObj.closedMessage);
          }
        };
      })(this));
      this.on("error", (function(_this) {
        return function(err, type, close, callback) {
          if (close == null) {
            close = false;
          }
          _this.emit('msg', (type + " error: ") + err);
          if (callback) {
            callback(err, type);
          }
          if (close) {
            return _this.connection.end();
          }
        };
      })(this));
    }

    SSH2Shell.prototype.connect = function() {
      var e, ref, ref1;
      if (this.sshObj.server && this.sshObj.commands) {
        try {
          this.connection.on("connect", (function(_this) {
            return function() {
              return _this.emit("connect");
            };
          })(this));
          this.connection.on("ready", (function(_this) {
            return function() {
              _this.emit("ready");
              return _this.connection.shell({
                pty: true
              }, function(err, _stream) {
                _this._stream = _stream;
                if (err) {
                  _this.emit('error', err, "Shell", true);
                }
                _this.sshObj.sessionText = "Connected to " + _this.sshObj.server.host + "\n";
                _this._stream.on("error", function(err) {
                  return _this.emit('error', err, "Stream");
                });
                _this._stream.stderr.on('data', function(data) {
                  return _this.emit('stderr', data, "Stream STDERR");
                });
                _this._stream.on("readable", function() {
                  var data, e, results;
                  try {
                    results = [];
                    while ((data = _this._stream.read())) {
                      results.push(_this._processData("" + data));
                    }
                    return results;
                  } catch (_error) {
                    e = _error;
                    return _this.emit('error', e + " " + e.stack, "Processing response:", true);
                  }
                });
                _this._stream.on("end", function() {
                  return _this.emit('end', _this.sshObj.sessionText, _this.sshObj);
                });
                return _this._stream.on("close", function(code, signal) {
                  if (_this._idleTimer) {
                    clearTimeout(_this._idleTimer);
                  }
                  return _this.connection.end();
                });
              });
            };
          })(this));
          this.connection.on("error", (function(_this) {
            return function(err) {
              return _this.emit("error", err, "Connection", true);
            };
          })(this));
          this.connection.on("close", (function(_this) {
            return function(had_error) {
              return _this.emit("close", had_error);
            };
          })(this));
          return this.connection.connect({
            host: this.sshObj.server.host,
            port: this.sshObj.server.port,
            username: this.sshObj.server.userName,
            password: this.sshObj.server.password,
            privateKey: (ref = this.sshObj.server.privateKey) != null ? ref : "",
            passphrase: (ref1 = this.sshObj.server.passPhrase) != null ? ref1 : ""
          });
        } catch (_error) {
          e = _error;
          return this.emit('error', e + " " + e.stack, "Connect:", true);
        }
      } else {
        return this.emit('error', "Missing connection parameters", "Parameters", false, missingParameters(err, type, close)(function() {
          this.emit('msg', this.sshObj.server);
          return this.emit('msg', this.sshObj.commands);
        }));
      }
    };

    return SSH2Shell;

  })(EventEmitter);

  module.exports = SSH2Shell;

}).call(this);
