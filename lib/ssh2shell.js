// Generated by CoffeeScript 1.11.1
(function() {
  var EventEmitter, SSH2Shell, typeIsArray,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  EventEmitter = require('events').EventEmitter;

  SSH2Shell = (function(superClass) {
    extend(SSH2Shell, superClass);

    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype.hosts = [];

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype.idleTime = 5000;

    SSH2Shell.prototype.asciiFilter = "";

    SSH2Shell.prototype.textColorFilter = "";

    SSH2Shell.prototype.passwordPromt = "";

    SSH2Shell.prototype.passphrasePromt = "";

    SSH2Shell.prototype.standardPromt = "";

    SSH2Shell.prototype._callback = function() {};

    SSH2Shell.prototype.onCommandProcessing = function() {};

    SSH2Shell.prototype.onCommandComplete = function() {};

    SSH2Shell.prototype.onCommandTimeout = function() {};

    SSH2Shell.prototype.onEnd = function() {};

    SSH2Shell.prototype.pipe = function() {};

    SSH2Shell.prototype.unpipe = function() {};

    SSH2Shell.prototype._processData = function(data) {
      this._buffer += data;
      if (this.command.length > 0 && !this.standardPromt.test(this._buffer.replace(this.command.substr(0, this._buffer.length), ""))) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Command waiting");
        }
        this.emit('commandProcessing', this.command, this._buffer, this.sshObj, this._stream);
        if (this.sshObj.idleTimer) {
          clearTimeout(this.sshObj.idleTimer);
        }
        this.sshObj.idleTimer = setTimeout((function(_this) {
          return function() {
            return _this.emit('commandTimeout', _this.command, _this._buffer, _this._stream, _this._connection);
          };
        })(this), this.idleTime);
      } else if (this.command.length < 1 && !this.standardPromt.test(this._buffer)) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": No command processing to first prompt");
        }
        this.emit('commandProcessing', this.command, this._buffer, this.sshObj, this._stream);
      }
      if (this.sshObj.dataReceivedTimer) {
        clearTimeout(this.sshObj.dataReceivedTimer);
      }
      return this.sshObj.dataReceivedTimer = setTimeout((function(_this) {
        return function() {
          if (_this.sshObj.idleTimer) {
            clearTimeout(_this.sshObj.idleTimer);
          }
          if (!_this.sshObj.disableColorFilter) {
            if (_this.sshObj.verbose) {
              _this.emit('msg', (_this.sshObj.server.host + ": text formatting filter: ") + _this.sshObj.textColorFilter + ", response is ok: " + _this.textColorFilter.test(_this._buffer));
            }
            _this._buffer = _this._buffer.replace(_this.textColorFilter, "");
          }
          if (!_this.sshObj.disableASCIIFilter) {
            if (_this.sshObj.verbose) {
              _this.emit('msg', (_this.sshObj.server.host + ": ASCII filter: ") + _this.sshObj.asciiFilter + ", response is ok: " + _this.asciiFilter.test(_this._buffer));
            }
            _this._buffer = _this._buffer.replace(_this.asciiFilter, "");
          }
          switch (true) {
            case _this.command.length > 0 && _this.command.indexOf("sudo ") !== -1:
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Password prompt: process ");
              }
              return _this._processPasswordPrompt();
            case _this.command.length > 0 && _this.command.indexOf("ssh ") !== -1:
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": SSH Password prompt: process ");
              }
              return _this._processSSHPrompt();
            case _this.command.length > 0 && _this.standardPromt.test(_this._buffer.replace(_this.command.substr(0, _this._buffer.length), "")):
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Normal prompt detected");
              }
              _this.sshObj.pwSent = false;
              return _this._commandComplete();
            case _this.command.length < 1 && _this.standardPromt.test(_this._buffer):
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": First prompt detected");
              }
              if (_this.sshObj.showBanner) {
                _this.sshObj.sessionText += _this._buffer;
              }
              return _this._nextCommand();
            default:
              if (_this.sshObj.debug) {
                _this.emit('msg', "Data processing: data received timeout");
              }
              return _this.sshObj.idleTimer = setTimeout(function() {
                return _this.emit('commandTimeout', _this.command, _this._buffer, _this._stream, _this._connection);
              }, _this.idleTime);
          }
        };
      })(this), 500);
    };

    SSH2Shell.prototype._processPasswordPrompt = function() {
      var response;
      response = this._buffer.replace(this.command.substr(0, this._buffer.length), "");
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Password prompt: Password Sent: " + this.sshObj.pwSent);
      }
      if (!this.sshObj.pwSent) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Password prompt: Buffer: " + response);
        }
        if (this.passwordPromt.test(response)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Password prompt: Send password ");
          }
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sent password: " + this.sshObj.server.password);
          }
          this.sshObj.pwSent = true;
          return this._stream.write("" + this.sshObj.server.password + this.sshObj.enter);
        } else if (this.standardPromt.test(response)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Password prompt: Standard prompt after password sent");
          }
          return this._commandComplete();
        }
      } else if (this.standardPromt.test(response)) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Password prompt: Standard prompt detected");
        }
        return this._commandComplete();
      } else {
        if (this.passwordPromt.test(response)) {
          if (this.sshObj.verbose) {
            this.emit('msg', this.sshObj.server.host + ": Sudo password faied: response: " + response);
          }
          this.emit('error', "Sudo password was incorrect for " + this.sshObj.server.userName, "Sudo authentication");
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Failed password prompt: Password: [" + this.sshObj.server.password + "]");
          }
          this.sshObj.sessionText += "" + this._buffer;
          this._buffer = "";
          this.sshObj.commands = [];
          this.command = "";
          return this._stream.write('\x03');
        }
      }
    };

    SSH2Shell.prototype._processSSHPrompt = function() {
      var password, response;
      response = this._buffer.replace(this.command.substr(0, this._buffer.length), "");
      if (!this.sshObj.sshAuth) {
        if (this.passwordPromt.test(response)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH password prompt");
          }
          this.sshObj.sshAuth = true;
          return this._stream.write("" + this.sshObj.server.password + this.sshObj.enter);
        } else if (this.passphrasePromt.test(response)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH passphrase prompt");
          }
          this.sshObj.sshAuth = "true";
          return this._stream.write("" + this.sshObj.server.passPhrase + this.sshObj.enter);
        } else if (this.standardPromt.test(response)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH auth normal prompt");
          }
          this.sshObj.sshAuth = true;
          this.sshObj.sessionText += "Connected to " + this.sshObj.server.host + this.sshObj.enter;
          return this._commandComplete();
        }
      } else {
        if ((password = this.passwordPromt.test(response) || this.passphrasePromt.test(response))) {
          this.sshObj.sshAuth = false;
          this.emit('error', "SSH authentication failed for " + this.sshObj.server.userName + "@" + this.sshObj.server.host, "Nested host authentication");
          if (this.sshObj.debug) {
            this.emit('msg', "Using " + (password ? "password: [" + this.sshObj.server.password + "]" : "passphrase: [" + this.sshObj.server.passPhrase + "]"));
          }
          if (this._connections.length > 0) {
            this._previousConnection();
          }
          this.sshObj.sessionText += "" + this._buffer;
          return this._stream.write('\x03');
        } else if (this.standardPromt.test(response)) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH complete: normal prompt");
          }
          return this._sshConnectionTest(response);
        }
      }
    };

    SSH2Shell.prototype._processNotifications = function() {
      var msgNote, sessionNote;
      if (this.command) {
        if ((sessionNote = this.command.match(/^`(.*)`$/))) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Notifications: sessionText output");
          }
          this.sshObj.sessionText += this.sshObj.server.host + ": Note: " + sessionNote[1] + this.sshObj.enter;
          if (this.sshObj.verbose) {
            this.emit('msg', sessionNote[1]);
          }
          return this._nextCommand();
        } else if ((msgNote = this.command.match(/^msg:(.*)$/))) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Notifications: msg to output");
          }
          this.emit('msg', this.sshObj.server.host + ": Note: " + msgNote[1]);
          return this._nextCommand();
        } else {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": Notifications: Normal Command to run");
          }
          return this._checkCommand();
        }
      }
    };

    SSH2Shell.prototype._commandComplete = function() {
      var response;
      response = this._buffer.replace(this.command, "");
      if (this.command.indexOf("sudo su") !== -1) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Sudo su adding exit.");
        }
        this.sshObj.exitCommands.push("exit");
      }
      if (this.command !== "" && this.command !== "exit" && this.command.indexOf("ssh ") === -1) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Command complete:\nCommand:\n " + this.command + "\nResponse: " + response);
        }
        this.sshObj.sessionText += response;
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Raising commandComplete event");
        }
        this.emit('commandComplete', this.command, this._buffer, this.sshObj);
      }
      if (this.command.indexOf("exit") !== -1) {
        return this._runExit();
      } else {
        return this._nextCommand();
      }
    };

    SSH2Shell.prototype._nextCommand = function() {
      this._buffer = "";
      if (this.sshObj.commands.length > 0) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Host.commands: " + this.sshObj.commands);
        }
        this.command = this.sshObj.commands.shift();
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Next command from host.commands: " + this.command);
        }
        return this._processNotifications();
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": No commands so exit");
        }
        return this._runExit();
      }
    };

    SSH2Shell.prototype._checkCommand = function() {
      if (this.command) {
        return this._runCommand(this.command);
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": No command so exit");
        }
        return this._runExit();
      }
    };

    SSH2Shell.prototype._runCommand = function(command) {
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": running: " + command);
      }
      return this._stream.write("" + command + this.sshObj.enter);
    };

    SSH2Shell.prototype._previousHost = function() {
      var host;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Switching host configs");
      }
      host = this.sshObj.server.host;
      this.emit('end', this.sshObj.sessionText, this.sshObj);
      if (this._connections.length > 0) {
        this._connections[0].sessionText += this.sshObj.sessionText;
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Pushed exit command to disconnect SSH session for " + host);
        }
        this.sshObj.exitCommands.push("exit");
        if (this.sshObj.idleTimer) {
          clearTimeout(this.sshObj.idleTimer);
        }
        this._removeEvents();
        this.sshObj = this._connections.pop();
        this._loadDefaults();
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.enter + "Previous host object:\n" + this.sshObj);
        }
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Reload previous host object");
        }
      }
      return this._runExit();
    };

    SSH2Shell.prototype._nextHost = function() {
      var nextHost, sshCommand;
      this._buffer = "";
      nextHost = this.sshObj.hosts.shift();
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": SSH to " + nextHost.server.host);
      }
      this._removeEvents();
      this._connections.push(this.sshObj);
      this.sshObj = nextHost;
      this._loadDefaults();
      this.sshObj.testConnection = true;
      sshCommand = "ssh -q " + this.sshObj.server.userName + "@" + this.sshObj.server.host + " \"echo 2>&1\" && echo OK || echo NOK";
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": SSH checking conectivity");
      }
      this.sshObj.commands.unshift(sshCommand);
      return this._nextCommand();
    };

    SSH2Shell.prototype._sshConnectionTest = function(response) {
      if (this.sshObj.testConnection) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": SSH: Connection test response: " + response + ".");
        }
        if (response.indexOf("NOK") === -1) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH: Okay to connect");
          }
          this.sshObj.testConnection = false;
          this._sshConnect();
        } else {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH: Connection not possible reverting host");
          }
          this.sshObj.commands = [];
          this.command = "";
          this._runExit();
        }
      } else {
        this.sshObj.sessionText += "Connected to " + this.sshObj.server.host + this.sshObj.enter;
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": SSH: Connected");
        }
        if (this.sshObj.hosts && this.sshObj.hosts.length === 0) {
          if (this.sshObj.debug) {
            this.emit('msg', this.sshObj.server.host + ": SSH: Connected: added exit command");
          }
          this.sshObj.exitCommands.push("exit");
        }
        return this._nextCommand();
      }
    };

    SSH2Shell.prototype._sshConnect = function() {
      var option, ref, sshCommand, sshFlags, sshOptions, value;
      sshFlags = "-x";
      sshOptions = "";
      if (this.sshObj.server.ssh) {
        if (this.sshObj.server.ssh.forceProtocolVersion) {
          sshFlags += this.sshObj.server.ssh.forceProtocolVersion;
        }
        if (this.sshObj.server.ssh.forceAddressType) {
          sshFlags += this.sshObj.server.ssh.forceAddressType;
        }
        if (this.sshObj.server.ssh.disablePseudoTTY) {
          sshFlags += "T";
        }
        if (this.sshObj.server.ssh.forcePseudoTTY) {
          sshFlags += "t";
        }
        if (this.sshObj.server.ssh.verbose) {
          sshFlags += "v";
        }
        if (this.sshObj.server.ssh.cipherSpec) {
          sshOptions += " -c " + this.sshObj.server.ssh.cipherSpec;
        }
        if (this.sshObj.server.ssh.escape) {
          sshOptions += " -e " + this.sshObj.server.ssh.escape;
        }
        if (this.sshObj.server.ssh.logFile) {
          sshOptions += " -E " + this.sshObj.server.ssh.logFile;
        }
        if (this.sshObj.server.ssh.configFile) {
          sshOptions += " -F " + this.sshObj.server.ssh.configFile;
        }
        if (this.sshObj.server.ssh.identityFile) {
          sshOptions += " -i " + this.sshObj.server.ssh.identityFile;
        }
        if (this.sshObj.server.ssh.loginName) {
          sshOptions += " -l " + this.sshObj.server.ssh.loginName;
        }
        if (this.sshObj.server.ssh.macSpec) {
          sshOptions += " -m " + this.sshObj.server.ssh.macSpec;
        }
        ref = this.sshObj.server.ssh.Options;
        for (option in ref) {
          value = ref[option];
          sshOptions += ' -o "#{option}={#value}"';
        }
      }
      sshOptions += ' -o "StrictHostKeyChecking=no"';
      sshOptions += " -p " + this.sshObj.server.port;
      this.sshObj.sshAuth = false;
      sshCommand = "ssh " + sshFlags + " " + sshOptions + " " + this.sshObj.server.userName + "@" + this.sshObj.server.host;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": SSH: connect");
      }
      this.sshObj.commands.unshift(sshCommand);
      return this._nextCommand();
    };

    SSH2Shell.prototype._runExit = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Run exit");
      }
      if (this.sshObj.exitCommands && this.sshObj.exitCommands.length > 0) {
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.server.host + ": Queued exit commands: " + this.sshObj.exitCommands);
        }
        this.command = this.sshObj.exitCommands.pop();
        return this._runCommand(this.command);
      } else if (this.sshObj.hosts && this.sshObj.hosts.length > 0) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Next host from this host");
        }
        if (this.sshObj.verbose) {
          this.emit('msg', this.sshObj.hosts);
        }
        return this._nextHost();
      } else if (this._connections && this._connections.length > 0) {
        return this._previousHost();
      } else {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Exit command: Stream: close");
        }
        return this._stream.close();
      }
    };

    SSH2Shell.prototype._removeEvents = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Clearing previous event handlers");
      }
      this.removeListener('commandProcessing', this.onCommandProcessing);
      this.removeListener('commandComplete', this.onCommandComplete);
      this.removeListener('commandTimeout', this.onCommandTimeout);
      return this.removeListener('end', this.onEnd);
    };

    SSH2Shell.prototype._loadDefaults = function() {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (!this.sshObj.msg) {
        this.sshObj.msg = {
          send: (function(_this) {
            return function(message) {
              return console.log(message);
            };
          })(this)
        };
      }
      if (!this.sshObj.connectedMessage) {
        this.sshObj.connectedMessage = "Connected";
      }
      if (!this.sshObj.readyMessage) {
        this.sshObj.readyMessage = "Ready";
      }
      if (!this.sshObj.closedMessage) {
        this.sshObj.closedMessage = "Closed";
      }
      if (!this.sshObj.showBanner) {
        this.sshObj.showBanner = false;
      }
      if (!this.sshObj.verbose) {
        this.sshObj.verbose = false;
      }
      if (!this.sshObj.debug) {
        this.sshObj.debug = false;
      }
      if (!this.sshObj.hosts) {
        this.sshObj.hosts = [];
      }
      if (!this.sshObj.commands) {
        this.sshObj.commands = [];
      }
      if (!this.sshObj.standardPrompt) {
        this.sshObj.standardPrompt = ">$%#";
      }
      if (!this.sshObj.passwordPromt) {
        this.sshObj.passwordPromt = ":";
      }
      if (!this.sshObj.passphrasePromt) {
        this.sshObj.passphrasePromt = ":";
      }
      if (!this.sshObj.enter) {
        this.sshObj.enter = "\n";
      }
      if (!this.sshObj.asciiFilter) {
        this.sshObj.asciiFilter = "[^\r\n\x20-\x7e]";
      }
      if (this.sshObj.disableColorFilter !== true) {
        this.sshObj.disableColorFilter = false;
      }
      if (this.sshObj.disableASCIIFilter !== true) {
        this.sshObj.disableASCIIFilter = false;
      }
      if (!this.sshObj.textColorFilter) {
        this.sshObj.textColorFilter = "(\[{1}[0-9;]+m{1})";
      }
      if (!this.sshObj.exitCommands) {
        this.sshObj.exitCommands = [];
      }
      if (!this.sshObj.pwSent) {
        this.sshObj.pwSent = false;
      }
      if (!this.sshObj.sshAuth) {
        this.sshObj.sshAuth = false;
      }
      this.sshObj.server.hashKey = (ref = this.sshObj.server.hashKey) != null ? ref : "";
      if (!this.sshObj.sessionText) {
        this.sshObj.sessionText = "";
      }
      this.sshObj.streamEncoding = (ref1 = this.sshObj.streamEncoding) != null ? ref1 : "utf8";
      if (!this.sshObj.window) {
        this.sshObj.window = true;
      }
      if (!this.sshObj.pty) {
        this.sshObj.pty = true;
      }
      this.idleTime = (ref2 = this.sshObj.idleTimeOut) != null ? ref2 : 5000;
      if (!this.asciiFilter) {
        this.asciiFilter = new RegExp(this.sshObj.asciiFilter, "g");
      }
      if (!this.textColorFilter) {
        this.textColorFilter = new RegExp(this.sshObj.textColorFilter, "g");
      }
      if (!this.passwordPromt) {
        this.passwordPromt = new RegExp("password.*" + this.sshObj.passwordPromt + "\\s$", "i");
      }
      if (!this.passphrasePromt) {
        this.passphrasePromt = new RegExp("password.*" + this.sshObj.passphrasePromt + "\\s$", "i");
      }
      if (!this.standardPromt) {
        this.standardPromt = new RegExp("[" + this.sshObj.standardPrompt + "]\\s?$");
      }
      if (this.sshObj.callback) {
        this._callback = this.sshObj.callback;
      }
      this._connections = [];
      this.onCommandProcessing = (ref3 = this.sshObj.onCommandProcessing) != null ? ref3 : (function(_this) {
        return function(command, response, sshObj, stream) {};
      })(this);
      this.onCommandComplete = (ref4 = this.sshObj.onCommandComplete) != null ? ref4 : (function(_this) {
        return function(command, response, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.commandComplete");
          }
        };
      })(this);
      this.onCommandTimeout = (ref5 = this.sshObj.onCommandTimeout) != null ? ref5 : (function(_this) {
        return function(command, response, stream, connection) {
          response = response.replace(_this.command, "");
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.commandTimeout");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', _this.sshObj.server.host + ": Timeout command: " + command + " response: " + response);
          }
          _this._runExit();
          return _this.emit("error", _this.sshObj.server.host + ": Command timed out after " + (_this.idleTime / 1000) + " seconds", "Timeout", true, function(err, type) {
            return _this.sshObj.sessionText += _this._buffer;
          });
        };
      })(this);
      this.onEnd = (ref6 = this.sshObj.onEnd) != null ? ref6 : (function(_this) {
        return function(sessionText, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.end");
          }
        };
      })(this);
      this.on("commandProcessing", this.onCommandProcessing);
      this.on("commandComplete", this.onCommandComplete);
      this.on("commandTimeout", this.onCommandTimeout);
      return this.on("end", this.onEnd);
    };

    function SSH2Shell(hosts) {
      this._connect = bind(this._connect, this);
      this._nextPrimaryHost = bind(this._nextPrimaryHost, this);
      this.connect = bind(this.connect, this);
      this._initiate = bind(this._initiate, this);
      this._loadDefaults = bind(this._loadDefaults, this);
      this._removeEvents = bind(this._removeEvents, this);
      this._runExit = bind(this._runExit, this);
      this._sshConnect = bind(this._sshConnect, this);
      this._sshConnectionTest = bind(this._sshConnectionTest, this);
      this._nextHost = bind(this._nextHost, this);
      this._previousHost = bind(this._previousHost, this);
      this._runCommand = bind(this._runCommand, this);
      this._checkCommand = bind(this._checkCommand, this);
      this._nextCommand = bind(this._nextCommand, this);
      this._commandComplete = bind(this._commandComplete, this);
      this._processNotifications = bind(this._processNotifications, this);
      this._processSSHPrompt = bind(this._processSSHPrompt, this);
      this._processPasswordPrompt = bind(this._processPasswordPrompt, this);
      this._processData = bind(this._processData, this);
      this.unpipe = bind(this.unpipe, this);
      this.pipe = bind(this.pipe, this);
      this.onEnd = bind(this.onEnd, this);
      this.onCommandTimeout = bind(this.onCommandTimeout, this);
      this.onCommandComplete = bind(this.onCommandComplete, this);
      this.onCommandProcessing = bind(this.onCommandProcessing, this);
      this._callback = bind(this._callback, this);
      if (typeIsArray(hosts)) {
        this.hosts = hosts;
      } else {
        this.hosts = [hosts];
      }
      this.connection = new require('ssh2')();
    }

    SSH2Shell.prototype._initiate = function() {
      var ref, ref1, ref2, ref3;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": initiate");
      }
      this.removeAllListeners();
      this.connection.removeAllListeners();
      this._loadDefaults();
      this.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          var str;
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.keyboard-interactive");
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Keyboard-interactive: finish([response, array]) not called in class event handler.");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', "name: " + name);
            _this.emit('msg', "instructions: " + instructions);
            str = JSON.stringify(prompts, null, 4);
            _this.emit('msg', "Prompts object: " + str);
          }
          if (_this.sshObj.onKeyboardInteractive) {
            return _this.sshObj.onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish);
          }
        };
      })(this));
      this.on("msg", (ref = this.sshObj.msg.send) != null ? ref : (function(_this) {
        return function(message) {
          return console.log(message);
        };
      })(this));
      this.on("error", (ref1 = this.sshObj.onError) != null ? ref1 : (function(_this) {
        return function(err, type, close, callback) {
          if (close == null) {
            close = false;
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.error");
          }
          if (err instanceof Error) {
            _this.emit('msg', "Error: " + err.message + ", Level: " + err.level);
          } else {
            _this.emit('msg', (type + " error: ") + err);
          }
          if (callback) {
            callback(err, type);
          }
          if (close) {
            return _this.connection.end();
          }
        };
      })(this));
      this.on("data", (ref2 = this.sshObj.onData) != null ? ref2 : (function(_this) {
        return function(data) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": data event");
          }
        };
      })(this));
      return this.on("stderrData", (ref3 = this.sshObj.onStderrData) != null ? ref3 : (function(_this) {
        return function(data) {
          return console.error(data);
        };
      })(this));
    };

    SSH2Shell.prototype.connect = function(callback) {
      if (callback) {
        this._callback = callback;
      }
      return this._nextPrimaryHost();
    };

    SSH2Shell.prototype._nextPrimaryHost = function() {
      var host;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Current primary host");
      }
      host = this.hosts.pop();
      this.sshObj = host;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Next primary host");
      }
      this._initiate();
      return this._connect();
    };

    SSH2Shell.prototype._connect = function() {
      var e;
      this.connection.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.keyboard-interactive");
          }
          return _this.emit("keyboard-interactive", name, instructions, instructionsLang, prompts, finish);
        };
      })(this));
      this.connection.on("connect", (function(_this) {
        return function() {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.connect");
          }
          return _this.emit('msg', _this.sshObj.connectedMessage);
        };
      })(this));
      this.connection.on("ready", (function(_this) {
        return function() {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.ready");
          }
          _this.emit('msg', _this.sshObj.readyMessage);
          return _this.connection.shell(_this.sshObj.window, {
            pty: _this.sshObj.pty
          }, function(err, _stream) {
            _this._stream = _stream;
            if (err instanceof Error) {
              _this.emit('error', err, "Shell", true);
              return;
            }
            if (_this.sshObj.debug) {
              _this.emit('msg', _this.sshObj.server.host + ": Connection.shell");
            }
            _this.sshObj.sessionText = "Connected to " + _this.sshObj.server.host + _this.sshObj.enter;
            _this._stream.setEncoding(_this.sshObj.streamEncoding);
            _this._stream.on("pipe", function(source) {
              if (_this.sshObj.debug) {
                emit("msg", "pipe for \n\n" + source);
              }
              return _this.on("pipe", source);
            });
            _this._stream.on("unpipe", function(source) {
              if (_this.sshObj.debug) {
                emit("msg", "unpipe for \n\n" + source);
              }
              return _this.on("unpipe", source);
            });
            _this._stream.on("error", function(err) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.error");
              }
              return _this.emit('error', err, "Stream");
            });
            _this._stream.stderr.on('data', function(data) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.stderr.data");
              }
              return _this.emit('stderrData', data);
            });
            _this._stream.on("data", function(data) {
              var e;
              try {
                _this.emit('data', data);
                return _this._processData(data);
              } catch (error) {
                e = error;
                err = new Error(e + " " + e.stack);
                err.level = "Data handling";
                return _this.emit('error', err, "Stream.read", true);
              }
            });
            _this._stream.on("pipe", function(source) {
              return _this.emit('pipe', source);
            });
            _this._stream.on("unpipe", function(source) {
              return _this.emit('unpipe', source);
            });
            _this._stream.on("finish", function() {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.finish");
              }
              _this.emit('end', _this.sshObj.sessionText, _this.sshObj);
              _this.sshObj.commands = "";
              if (_this._callback) {
                return _this._callback(_this.sshObj.sessionText);
              }
            });
            return _this._stream.on("close", function(code, signal) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.close");
              }
              if (_this.sshObj.dataReceivedTimer) {
                clearTimeout(_this.sshObj.dataReceivedTimer);
              }
              _this.removeAllListeners();
              _this.connection.end();
              return _this.connection.removeAllListeners();
            });
          });
        };
      })(this));
      this.connection.on("error", (function(_this) {
        return function(err) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.error");
          }
          return _this.emit("error", err, "Connection");
        };
      })(this));
      this.connection.on("close", (function(_this) {
        return function(had_error) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.close");
          }
          if (_this.sshObj.idleTimer) {
            clearTimeout(_this.sshObj.idleTimer);
          }
          if (had_error) {
            _this.emit("error", had_error, "Connection close");
          } else {
            _this.emit('msg', _this.sshObj.closedMessage);
          }
          if (_this.hosts.length > 0) {
            return _this._nextPrimaryHost();
          }
        };
      })(this));
      if (this.sshObj.server && this.sshObj.commands) {
        try {
          this.connection.connect({
            host: this.sshObj.server.host,
            port: this.sshObj.server.port,
            forceIPv4: this.sshObj.server.forceIPv4,
            forceIPv6: this.sshObj.server.forceIPv6,
            hostHash: this.sshObj.server.hashMethod,
            hostVerifier: this.sshObj.server.hostVerifier,
            username: this.sshObj.server.userName,
            password: this.sshObj.server.password,
            agent: this.sshObj.server.agent,
            agentForward: this.sshObj.server.agentForward,
            privateKey: this.sshObj.server.privateKey,
            passphrase: this.sshObj.server.passPhrase,
            localHostname: this.sshObj.server.localHostname,
            localUsername: this.sshObj.server.localUsername,
            tryKeyboard: this.sshObj.server.tryKeyboard,
            keepaliveInterval: this.sshObj.server.keepaliveInterval,
            keepaliveCountMax: this.sshObj.server.keepaliveCountMax,
            readyTimeout: this.sshObj.server.readyTimeout,
            sock: this.sshObj.server.sock,
            strictVendor: this.sshObj.server.strictVendor,
            algorithms: this.sshObj.server.algorithms,
            compress: this.sshObj.server.compress,
            debug: this.sshObj.server.debug
          });
        } catch (error) {
          e = error;
          this.emit('error', e + " " + e.stack, "Connection.connect", true);
        }
      } else {
        this.emit('error', "Missing connection parameters", "Parameters", false, function(err, type, close) {
          this.emit('msg', this.sshObj.server);
          return this.emit('msg', this.sshObj.commands);
        });
      }
      return this._stream;
    };

    return SSH2Shell;

  })(EventEmitter);

  module.exports = SSH2Shell;

}).call(this);
